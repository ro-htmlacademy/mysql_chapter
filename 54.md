# SQL инъекции

Тема в основном интересна просто нереальным количеством заблуждений, с ней связанных. В чем отметился и основной учебник, о чем будет отдельно сказано ниже.

Само по себе понятие инъекции не представляет из себя ничего сложного:   
Поскольку SQL запрос представляет из себя программу на языке SQL, и мы формируем эту программу динамически, добавляя в неё элементы на лету, то эти элементы могут повлиять на синтаксис программы, и привести - в лучшем случае - к ошибкам, а в худшем - к намеренной манипуяции запросом.

### Пример

Пример такой манипуляции показан в известнейшем комиксе, https://xkcd.ru/327/

Допустим, РНР код выглядит так - мы просто подставляем переменную 

    $SQL = "INSERT INTO Students VALUES ('$Name')";
    
а в $name у нас будет `Robert'); DROP TABLE Students; -- ` и запрос получится вот такой

    INSERT INTO Students VALUES ('Robert'); DROP TABLE Students; -- ');
    
что здесь происходит?

- сначала в $name идет имя, хотя это и не обязательно - можно было бы сразу поставить закрывающую кавычку. Добавлено для художественности
- затем одинарная кавычка, которая закрывает строковый элемент
- затем идет скобка, которая закрывает оператор VALUES
- затем точка с запятой, которая завершает запрос
- затем пишется вредоносный запрос `DROP TABLE Students;`
- затем идет оператор комментария `-- `, текст после которого игнорируется базой данных, чтобы эти остатки не помешали второму запросу (можно, кстати, обойтись и без них)
- затем идут остатки оригинального запроса, `');`, которые, как было сказано выше, просто игнорируются

И хотя применимость данного запроса в конкретных условиях - это отдельный вопрос, в качестве иллюстрации *уязвимости* он подходит идеально.   
поскольку очень важно различать два понятия: саму уязвимость, и *конкретный эксплойт*. Эти два понятия постоянно путают, и это порождает полный хаос в рассуждениях.

Разумеется, конкретный эксплойт выглядит гораздо эффектнее. А, главное, можно жонглировать загодочными терминами - "слепая инъекция", "инъекция второго порядка", "инъекция базирующаяся на времени отклика"... Вот только дело в том, что это всё - эксплойты. Которые с точки зрения защиты нам совершенно **не интересны**. Хуже того - попытки защищаться от эксплойтов приводят к совершенно идиотским идеям типа запрещать во входящих данных смивол комментария, слово delete и пр. Это всё полная чушь, которая мало того что не имеет ни малейшего смысла, не только ухудшает функционал приложения (ну что это за база данных, которая не разрешает хранить определённые слова? ) но и является фатальной с точки зрения защиты: количество эксплойтов по определению бесконечно, и защитившись от десяти, мы пропустим одиннадцатый. 

**Защищаться надо не от эксплойтов, а от инъекции.** То есть предотвращать *саму возможность* модифицировать код запроса.  

И если мы защитимся от самого факта инъекции, то все эти красивые слова, и миллионы хитроумных эксплойтов рассыпятся в прах, станут безобидным мусором. То есть наша защита будет этаким Нео, который не глядя отмахивается от летящих со всех сторон пуль.

### Заблуждения

С защитой так же связано огромное количество заблуждений, мифов, и суеверий.

Самое, пожалуй, катастрофическое - как по распространённости, так и по последствиям - это утверждение, что функция `mysqli_real_escape_string()` *предназначена* для защиты от инъекций. На самом деле это полная чушь, к инъекциям эта функция имеет косвенное отношение, но главное - никогда не должна применяться в целях защиты. Печальные последствия этого заблуждения можно наблюдать сплошь и рядом, в частности, [в коде](https://github.com/htmlacademy-php/60877-yeticave-12/blob/ad324e4c3d8968bcc48654df78f50264dede249c/lot.php#L10) студентов, следующих близроуким рекомендациям из основного учебника. 

Так же очень большой вред приносят *рассуждения*. Многие допускают ошибку, пытаясь бороться против каких-то косвенных деталей, вместо того чтобы защищаться от инъекций. И особняком в этом ряду стоят рассуждения о том, какие данные надо защищать, а какие - нет. При защите следует исходить из принципа, **Защищать надо запрос, а не данные**. Что это за данные, откуда они пришли, насколько безопасны - нас не должно интересовать от слова "совсем". Игнорирование этого принципа рано или поздно приведет к инъекции. Нас всегда должен интересовать только конечный **пункт назначения**, а не источник данных. Данные идут в SQL запрос? Защищаем. Простой как 3 копейки и на 100% эффективный принцип. 

Ещё очень часто можно встретить рассуждения типа "ну у меня учебный проект, его никто ломать не будет". Это настолько многоплановая глупость, что у меня даже нет слов. Если подумать, то

- инъекция вляется лишь частным случаем ошибки запроса. Если код пропускает инъекции, значит от также подвержен и ошибкам. Ошибки в учебном проекте уж точно не нужны
- зачем вообще сначала учиться делать неправильно, а потом переучиваться?!
- любой проект развивается и в какой-то момент превращается из учебного в рабочий

### Защита

Защита от SQL инъекций сводится к строгому следованию двум пунктам

1. Любые *данные* должны добавляться в запрос **только** через плейсхолдеры
2. Любые другие элементы запроса должны выбираться из *белого списка* - заранее прописанных в нашем коде значений.

Почему важно первое? Потому что добавленное через плейсхолдер значение гарантированно предохраняет нас от любых ошибок, котоыре могут быть вызваны данными, и в частности - от инъекций. Все остальные способы требуют целого сваода правил и оговорок. А это очень простой для запоминания и применения*, а главное - однозначный способ. Подробно он был рассмотрен в главе 5.1

Почему важно второе? Бывает так, что нам надо доавить в запрос переменную, которая сдержит не данные, а, скажем, имя поля. В этом случае замена на плейсхолдер не сработает (и скажет об этом сразу), а строковое экранирование поможет как мёртвому припарки, и будет пропускать все возможные инъекции (но мы об этом узнаем только постфактум). 

К счастью, в случае имен полей/команд SQL, список возможных вариантов заведомо ограничен. Поэтому мы можем заранее прописать все варианты в коде, и выбирать из них.

    $allowed = ["name","price","qty"]; // перечисляем все варианты
    if(array_search($_GET['order'], $allowed) === false); // ВАЖНО использовать === false
        throw new \InvalidArgumentException("Несуществующее поле"); 
    }
    
и дальше уже можем безопасно использовать подставлять `$_GET['order']` в запрос. 

# Упрощение работы с подготовленными выражениями

Выше я конечно погорячился, написав что подготовленные запросы *простые* для применения. Писать по 4 строчки на каждый запрос - это как-то уж очень занундно. Но это правда смотря с чем сравнивать. 4 строчки все-таки лучше столба из `mysqli_real_escape_string` когда у нас запрос на вставку из 10 полей (не говоря уже о том что этот столб не гарантирует защиту).

Впрочем, не все подготовленные выражения одинаково сложны. В PDO можно написать подготовленный запрос в одну строчку:

    $pdo->prepare("INSERT INTO t (name, price, qty) VALUES (?,?,?)")->execute([$name, $price, $quantoty]);
    
Но в mysqli доступен только вот такой замысловатый ситаксис, который мы освоили выше. К счастью, нашей профессией является программирование, а это значит что мы можем сами для себя создавать какие угодно инструменты для упрощения каких угодно операций. 

В частности, мы вполне можем написать функцию, которая сделает подготовленные запросы такими же простыми в использовании, как и запросы без переменных.

> **Важно!** Написание той функции будет представлять из себя отдельную, дополнительную задачу, по окончании работы над заданием.  Ни в коем случае нельзя применять её с самого начала. Необходимо сначала освоить исходный синтаксис подготовленных выражений. Выполнение этой задачи не является обязательным, при желании её можно пропустить. 

На самом деле в коде проекта, в файле helpers.php, уже есть пример такой функции, но на мой вгляд она просто чудовищная: неимоверно раздута, с кучей лишнего кода (но при этом не включает в себя некоторые нужные элементы). Не говоря уже о таких ужасных вещах, как вывод ошибок прямо на экран, что опять же является признаком ученического, а не профессионального подхода. Эта функция явно писалась студентом под себя, совершенно без учета того факта, что она может когда-нибудь использоваться на боевом сайте: **посетителю сайта** совершенно неинтересно читать про то, что программисту "Не удалось инициализировать подготовленное выражение". Такого рода ошибки **никогда** не должны выводиться на экран. И почему в курсе для них сделано исключение, остаётся для меня загадкой.    
Не говоря уже о том, что мы при подключении уже задали режим выбороса ошибок mysqli, и вручную проверять ошибки просто не нужно.

Так же в коде функции есть много дугого лишнего кода, например попытка определить тип переменной. Этого делать никогда не надо, по двум причинам

- во-первых, это не нужно. Mysql с огромным удовольствием примет любые данные как строки. 
- во-вторых, такое "вынюхивание" типа может привести к совершенно катастрофическим последствиям. Дело в том, что как и в РНР, в mysql используется слабая типизация. И в частности любая строка равна числу ноль. А это значит, что запрос вида `"delete from users where email=0` **удалит всех пользователей** в таблице! В то время как запрос `delete from users where email='0'` не удалит ни одной строки. Как говорят англичане, "Better safe than sorry", что можно перевести как "Лучше подстраховаться, чем потом пожалеть". И забыть про вынюхивание типа переменной как страшный сон. А просто всегда привязывать все переменные с типом `s`.

На тот редкий случай, когда надо будет указать какой-то другой тип, отличный от s, мы просто добавим к функции необязательный параметр, в котором можно будет указать типы вручную

Ну и напоследок, мы включим в состав функции исполнение запроса, поскльку писать его отдельно не имеет ни малейшего смысла. 

Важно! Функция **не** должна возвращать  результат get_result(). По той простой причине, что она будет использоваться не только для запросов SELECT, а у запросов на вставку или обновление никакого result нету. Посто возвращаем $stmt.





