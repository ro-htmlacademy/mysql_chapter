# Глава 5.2. Выполнение запросов

Все запросы, которые выполняются из РНР, можно разделить на две большие группы - те, в которых не используются переменные, и те, в которые надо подставлять какие-либо данные. Выполняются эти запросы совершенно разными способами.

Также можно разделить запросы на выборку данных (строго говоря, именно эти запросы и называются SQL), и запросы, которые меняют данные в БД (они еще называются DML). С точки зрения РНР между ними нет особенной разницы, просто для первых после выполнения запроса надо еще запросить полученный результат. 

# Запросы, в которых не используются переменные

Это самый простой вариант, и практически не отличается от того, как мы работали с запросами через клиента. Для таких случаев используется функция `mysqli_query()` (и её объектый вариант - просто `query()`). Мы просто берём готовый SQL запрос, например
```SQL
INSERT INTO users SET email = 'developer@php.net', password = 'hash'
```
помещаем его в переменную РНР, и выполняем  с помощью данной функции, используя переменную `$db`, полученную при соединении:
```php
$sql = "INSERT INTO users SET email = 'developer@php.net', password = 'hash'";
$db->query($sql);
```
И у нас в БД появляется новая запись! (Если, конечно, при записи не произошла ошибка).

Эта функция также возвращает результат своего выполнения. Для DML запросов результат может быть `true` или `false`, и нам он не интересен, а для запросов на выборку данных, таких как SELECT и некоторых других, возвращается ссылка на результат, из которой можно получить строки, которые вернула БД:

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
```

# Получение строк, которые вернул запрос. 

Для получения результатов запроса используется специальная переменная, коорая является экземпляром класса `mysqli_result`. Все функции получения строк работают именно с ней. 
Самым основным, базовым вариантом выборки полученных данных, является выборка одной строки результата. Причём этот вариант используется и если мы запрашивали только одну строку, так и если несколько. Во втором случае функция получения строки просто вызывается несклько раз, последовательно в цикле. 

Таких функций в mysqli несколько, и они отличаются тем, как мы обращаемся к отдельным полям запроса, однако самой часто используемой является `mysqli_fetch_assoc()`, которая возвращает ассоциативный массив, её мы и будем использовать в примерах.

### Получение единственной строки

Если нам надо получить из результата одну-единственную строку, то мы просто обращаемся к этой функции и получаем ассоциативный массив, к элементам которого можно потом обращаться для получения информации:

```php
$sql = "SELECT * FROM categories WHERE code='boards'";
$result = $db->query($sql);
$row = $result->fetch_assoc();
echo "Категория: {$row['name']}";
```
Как видно, имена ключей в массиве совпадают с именами полей в таблице, что очень удобно.

### Получение нескольких строк в цикле

Это очень интересная тема, поскольку для получения нескльких строк служит та же самая функция, что и для оплучения одной строки. Весь секрет тут в том, что каждый последующий вызов функции fetch_assoc (и её собратьев) *перемещает внутренний указатель в результате запроса на следующую строку*. То есть если написать такой код,

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$row = $result->fetch_assoc();
echo "1-я Категория: {$row['name']}";
$row = $result->fetch_assoc();
echo "2-я Категория: {$row['name']}";
```
То он нам вернёт названия двух первых категорий. 

Но конечно же, так писать по сто раз одно и то же никто не будет. И здесь нам напомощь придёт цикл. И тот факт, что когда `fetch_assoc()` переберёт все строки, то вместо следующей строки она вернёт `null`. И этот факт мы можем использовать для органицации цикла `while()`:

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
while ($row = $result->fetch_assoc()) {
    echo "Категория: {$row['name']}<br />\n";
}
```
Здесь цикл будет выполняться до тех пор, пока в $row возвращается массив, и прекращает выполнение, когда приходит null. 
То есть такой цикл переберёт все записи и завершится!

### Получение нескольких строк в массив

Но поскольку в современном веб-приложении мы **никогда** не выводим данные напрямую из БД, а всегда выводим только в шаблоне, то вместо вывода нам надо собирать полученные строки в массив. Это просто:
```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$data = []; // всегда надо инициализировать пустой массив
while ($row = $result->fetch_assoc()) {
    $data[] = $row;
}
```
Таким образом мы получим массив, состоящий из всех строк, которые вернула БД. 

Код получился довольно длинный, но к счастью, в mysqli есть удобная функция, `fetch_all()`, которая может вернуть массив за один раз. В качестве параметра она принимает одну из двух констант, которые определяют конечный вид получаемых строк - `MYSQLI_ASSOC` для ассоциативного массива и `MYSQLI_NUM` - для нумерованного:
```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$data = $result->fetch_all(MYSQLI_ASSOC);
```
Но при этом следует понимать, что разницы, кроме количества кода, тут никакой - "под капотом" у этой функции ровно тот же самый цикл `while`. 

Так же следут помнить, что `fetch_all()` пригодится только если нас устроит результат запроса "как есть" - нумерованный массив, содержащий все строки по порядку.
Если нам требуется предварительная обработка получаемых строк (например изменить индексы массива с чисел по возрастанию на значение их БД), то стоит вернуться к предыдущему варианту.

Так же цикл `while` используется для обработки больших объемов данных. На веб-страницах, показываемых пользователю, таких объемов в принципе быть не должно, но если у нас утилита командной строки, которая должна перебрать все строки из таблицы в которой хранятся записи миллиона пользователей, то тут только в цикле по одной!

# Запросы с использованием переменных

Такие запросы - совершенно особая статья, и это очень важный момент. 

Дело в том что SQL запрос - это пусть и небольшая, но настоящая программа, со своим синтаксисом. И добавляя в программу элементы на лету, можно нарушить синтаксис, что в *лучшем* случае приведёт к ошибкам, а в худшем - к уязвимости, называемой "SQL инъекция", когда нехороший человек подставит в наш запрос свои команды и будет делать в базе данных всё что захочет. Поэтому любые переменные необходимо **передавать в БД отдельно от запроса**. Это делается с помощью подготовленных, или, как их ещё называют, параметризованных запросов.

Чтобы выполнить параметризованный запрос, необходимо выполнить 4 действия:

1. Заменить все переменные в запросе на специальные маркеры, которые называются *плейсхолдеры* или *параметры*, а по сути - просто знаки вопроса
2. Подготовить запрос к исполнению с помощью функции `prepare()`. Эта функция принимает строку запроса и возвращает экземпляр специального класса `mysqli_stmt`, с которым в дальнейшем и производятся все манипуляции
3. Привязать переменные к запросу с помощью `bind_param()`. Это очень интресная функция. Она принимает в качестве параметров все переменные, которые должны попасть в запрос, в том же самом порядке, в котором стоят плейсхолдеры в запросе. Но кроме того, сначала в этой функции должны быть указаны типы для всех переменных, в виде строки, где тип переменной обозначается одной буквой. То есть букв в этой строке должно быть ровно столько, сколько дальше будет переменных. К счастью, можно особо не париться с типами и для всех переменных указывать тип "s". 
4. Выполнить запрос с помощью с помощью `execute()`. Эта функция выполняется без параметров

На словах это звучит длинно, но на практике не так сложно: представим, что у нас есть две переменные, `$email` и `$hash`, которые нам надо записать в таблицу `user`:
```php
$sql = "INSERT INTO users SET email = ?, password = ?"; // заменяем на знаки вопроса
$stmt = $db->prepare($sql); // подготавливаем запрос, получаем stmt
$stmt->bind_param("ss", $email, $hash); // два знака вопроса - две переменных - две буквы s
$stmt->execute(); // выполняем запрос
```
Не так уж и сложно, учитывая что такой подход **гарантирует** нас от ошибок синтаксиса и инъекций. 

Если на любом из этих этапов произойдет ошибка, то mysqli проинформирует нас о ней, благодаря режиму, который мы включили в предыдущей главе.

### Получение результата подготовленного запроса

Для получения строк, которые вернул подготовленный запрос, служит специальная функция `get_result()`. Она возвращает уже знакомую нам переменную типа `mysqli_result` из которой мы уже можем получить сами строки:
```php
$sql = "SELECT * FROM lots WHERE id=?"; // заменяем на знаки вопроса
$stmt = $db->prepare($sql); // подготавливаем запрос, получаем stmt
$stmt->bind_param("ss", $email, $hash); // два знака вопроса - две переменных - две буквы s
$stmt->execute(); // выполняем запрос
$result = $stmt->get_result(); // получаем result
$lot = $result->fetch_assoc(); // получаем строку или массив или перебираем по одной, как показано выше
```

И дальше уже мы работаем с результатом запроса так как было показано выше

