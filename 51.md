# Глава 5.1. Установка соединения

Мы уже познакомились с запросами SQL, теперь настало время научиться выполнять их из РНР.

Для работы с БД MySQL в РНР доступны два расширения - универсальное [PHP Data Objects](https://www.php.net/pdo), которое поддерживает работу с множеством разных БД, и [mysqli](https://www.php.net/mysqli), работающее только с MySQL. Хотя в профессиональной разработке практически всегда используется PDO и библиотеки на его базе, на этапе изучения лучше подойдёт mysqli, поскольку позволяет освоить самые базовые приёмы работы с БД и дает понимание того, как работают все более высокоуровневые библиотеки изнутри. 

# Последовательность работы с MySQL из PHP-сценария

Работа с БД происходит в РНР по одному и тому же типовому сценарию: сначала происходит соединение, затем выполняются запросы, а затем пользователю возвращается результат выполняния запроса. Это может быть или HTML страница с данными, которыми запросил пользователь, или сообщение об ошибке, или перенаправление на другую страницу. 

Данная схема представлена на иллюстрации ниже: 

![](https://up.htmlacademy.ru/assets/intensives/php/12/book/images/image-20200320115539808.png)

То есть в самом начале создаём подключение, присваивая значение переменной `$db`, а затем эта переменная используется для выполнения запросов на всем протяжении сценария. 

> **Важно!** Соединение с одной и той же БД всегда должно быть строго одно. Ни в коем случае не следует создавать несколько соединений, и тем более не следует соединяться в каждой функции заново. Если внутри функции требуется соединение с БД, то его надо передать в эту функцию как один из параметров, например:
```php
function get_bids($db, $log_id) {
   // выполняем запросы, используя $db
}
```

# Объектный и процедурный интерфейсы

Перед тем как переходить к конкретным примерам кода, необходимо определиться с синтаксисом. Дело в том, что у Mysqli есть одна уникальная особенность: это расширение реализует как объектный, так и процедурный интерфейс. То есть одну и ту же команду можно выполнить как обратившись к функции, так и к методу объекта:
```php
mysqli_query($mysqli, $query); // процедурный
$mysqli->query($query); // объектный
```
Отличие объектного интерфейса только в том, что мы берем параметр функции (`$mysqli`), приписываем к нему объектный оператор `->` и дальше обращаемся к той же функции, отрезав от неё ставшее ненужным слово "mysqli".    

Оба варианта полностью взаимозаменяемы, отличия чисто стилистические. Использовать можно любой. 
Однако поскольку объектный синтаксис выглядит проофессиональнее, плюс процедурный банально требует больше писанины, требуя постоянно повторять одно и то же по два раза (ср. `mysqli_stmt_get_result($stmt)` и `$stmt->get_result()`), то рекомендованным является объектный синтаксис, который мы и будем применять в примерах ниже. Но в своей работе можно использовать любой, по желанию.

# Соединение с БД.

При соединении с БД необходимо учитывать три основных момента: помимо собственно подключения, надо обязательно включить режим информирования об ошибках, а так же сообщить БД, какая крдировка используется в РНР сценарии.

### Подключение

Для подключения используется функция `mysqli_connect()` или - в объектном варианте - создание объекта, `new mysqli()`.   
Эта функция принимает несколько параметров, самыми важными из которых являются первые пять:

- **хост**. Имя хоста базы данных. При обучении в подавляющем большинстве случаев это `loacalhost` или `127.0.0.1` что одно и тоже. На боевом сервере имя хоста может быть другим, необходимо узнать его у админа БД или провайдера. 
- **имя пользователя БД**. На домашнем компьютере нет проблем использовать пользователя `root`, но на боевом сервере сайт не работает под рутом никогда. Имя так же надо узнавать у провайдера. 
- **пароль**. На домашнем может быть пустым или `root`, на боевом указывать обязательно.
- **имя базы данных**. Та база данных которую вы создавали в предыдущей главе.
- **порт** (опционально). По умолчанию Mysql работает на порту 3306, однако некоторые готовые сборки программ, особенно на компьютерах Mac, часто используют другой порт. Если он отличается, то его необходимо указать пятым параметром. 

Пример:
```php
$db = new mysqli("127.0.0.1", "root", "root", "yeticave");
```
### Режим информирования об ошибках

Это очень важная опция, которая значительно облегчает работу программиста и сильно упрощает код. 

По умолчанию функции mysqli очень молчаливы, и ничего не сообщают о возникающих ошибках. Это очень неудобно, поскольку сообщения об ошибках позволяют программисту понять, что не так с его кодом. Теоретически можно вызвать специальную функцию, которая вернет сообщение об ошибке, как это часто показывается в устаревших учебниках, но с этим есть две проблемы: во-первых, нам эта функия нужна только если ничего не работает. А если работает - то не нужна. Так и бегать всё время, то добавлять её, то убирать? А во-вторых - ну банально зачем вообще самому совершать какие-то действия, если они можгут выполняться автоматически? Поэтому надо просто один раз перед соединением задать режим информирования об ошибках, и больше этим вопросом себе голову не забивать. Работы меньше, код - чище.

Для задания режима информирования об ошибках служит функция `mysqli_report()`. В качестве аргумента она принимает комбинацию флагов. Наиболее удобной комбинацией является `MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT`, которая заставит mysqli выбрасывать исключения при возникновении ошибок MySQL. 

Пример:
```php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
```
(поскольку это единственный случай, когда процедурный синтаксис проще объектного, то мы будем использовать именно его)

### Указание кодировки

Важно понимать, что Mysql поддерживает работу с множеством кодировок и умеет перекодировать данные из одной кодировки в другую на лету. Что может привести к проблемам, если БД будет думать что данные в одной кодировке, а на самом деле они в другой (и тогда в БД появляются "вопросики" и "кракозябры"). Поэтому при соединении с БД всегда надо явно указать кодировку, в которой мы  отправляем данные в БД и в какой хотим получать их обратно. Поскольку стандартом де-факто в настоящее время является кодировка UTF-8, то указывать надо именно её. В MySQL кодировка, полностью поддерживающая стандарт UTF-8 называется `utf8mb4`.

Пример:
```php
$db->set_charset("utf8mb4")
```

# Пример подключения
```php
$db_host = '127.0.0.1';
$db_username = 'root';
$db_password = '';
$db_database = 'yeticave';
$db_port = 3306;
$db_charset = "utf8mb4";

mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$db = new mysqli($db_host, $db_username, $db_password, $db_database, $db_port);
$db->set_charset($db_charset);
```
Здесь мы собрали все описанные выше команды воедино, плюс вынесли все настройки в переменные, что в последствии облегчит работу нашего кода на разных компьютерах.

# Работа над ошибками

При ошибке подключения данный код самостоятельно сообщит об ошибке, например

```
PHP Fatal error:  Uncaught mysqli_sql_exception: Access denied for user 'root'@'localhost' (using password: YES) 
in C:\SERVER\www\yeticave\bootstrap.php:10
Stack trace:
#0 C:\SERVER\www\yeticave\bootstrap.php(10): mysqli->__construct('127.0.0.1', 'root', '12', 'yeticave', 3306)
#1 {main}
  thrown in C:\SERVER\www\yeticave\bootstrap.php on line 10
```

В данном случае ошибка означает, что был указан неверный пароль. 

Вообще, при возникновении ошибок, очень важно уметь их читать. поэтому разберем данное сообщение подробно.

 - `PHP Fatal error:  Uncaught mysqli_sql_exception:`  - это стандартный текст который не несёт никакой полезной информации (хотя иногда имя исключения может пригодиться)
 - `Access denied for user 'root'@'localhost' (using password: YES)` - собственно текст ошибки, который пришел из MySQL. Самая важная, информативная часть. то есть надо постараться это сообщение перевести и понять. Если же не получается, то можно поискать его в интернете. Надо взять эту часть, и вставить в адресную строку браузера. Поскольку большинство ошибок являются типовыми, то сразу же же найдется и объяснение, и рекомендации по исправлению. 
- `in C:\SERVER\www\yeticave\bootstrap.php:10` показывает точное место, где произошла ошибка, имя файла и через двоеточие, номер строки. Для ошибки соединения с БД это не очень важно, но при ошибках запросов это будет незаменимой информацией, поскольку покажет, какой конкретно запрос вызвал ошибку.
- `Stack trace:` последовательность действий, которая привела в ошибке. Хотя в небольших проектах обычно достаточно имени файла и строки, где произошла ошибка, в больших проектах со сложной структурой проблема может возникнуть ранее по коду, а привести к ошибке уже после. С помощью списка вызывавшихся функций можно будет найти проблемое место.

# Закрытие соединения

В большинстве случаев закрывать соединеие с БД не нужно. После завершения работы скрипта РНР закрывает все открытые в нем ресурсы автоматически, в том числе и соединение с БД. То есть в 99% случаев закрывать вручную не нужно. Только в ислючительных случаях можно воспользоваться функцией `$db->close()`.


# Распределённая работа над проектом

В реальной жизни проект всегда запускается на разных серверах. Как минимум, это локальный сервер разработчика и боевой сервер на котором крутится сайт. Обычно настройки на таких серверах не совпадают, например пароли для доступа к БД. Так же локальные сервера со своими настройками есть и у других разработчиков. В рамках курса примером такой многосерверной конфигурации могут служить компьютеры студента и наставника. И это сразу вызывает проблемы - код, который работает у студента, будет выдавать ошибку подключения к БД у наставника.

По этой причине специфичные для сервера настройки приложения выносятся в отдельный файл, который **исключается** из системы контроля версий, и таким образом может быть различным у каждого. Ниже приводится инструкция от наставника Сергей Парфёнов, которую он написал в чате интенсива

1. В приложениях принято хранить настройки в файле конфигурации, например в `config.php`
2. Сам файл конфигурации заливать в репозиторий не принято, так как у всех участников команды будут разные настройки (отличатся пароли к mysql, итд). Поэтому:
`config.php` добавляем в `.gitignore`, чтобы он не добавлялся в репозиторий.
3. Но при этом в репозиторий добавляем файл `config.sample.php` в качестве примера, по которому другие участники команды будут создавать свой `config.php`.
4. Перед подключением `config.php` можно проверять существование этого файла. Если файл не существует, то: 

        if (!file_exists('config.php'))
        {
            $msg = 'Создайте файл config.php на основе config.sample.php и внесите туда настройки сервера MySQL';
            trigger_error($msg,E_USER_ERROR);
        }
5. Данные в файле конфигурации можно хранить в виде массива. Можно использовать следующую конструкцию для подключения:

        return [
            'db' => [
                'host' => 'localhost',
                'user' => '',
                'password' => '',
                'database' => '',
            ],
        ];
        
`return` в подключаемом файле позволяет присвоить значение переменной через require:

    $config = require 'config.php';
    
И итоге в переменной `$config` мы получим массив с настройками нашего приложения.

